tally <- matrix(c(t, colSums(X_g)), ncol = ncol(X_g) + 1)
colnames(tally) <- c("t", colnames(X_g))
tally <- transform(tally, Inactive = n - sum(X_g), n = n, replicate = sim)
taskTally[[t]] <- tally
# Update total task performance profile
X_tot <- X_tot + X_g
# Create time step for correlation
if (t %% corrStep == 0) {
# Get tasks performance in correlation step
X_step <- X_tot - X_prevTot
# Add to ensemble list of task steps
taskStep[[t / corrStep]] <- X_step
# Calculate rank correlation if it is not the first step
if(sum(X_prev) != 0) {
# Normalize
stepNorm <- X_step / rowSums(X_step)
prevNorm <- X_prev / rowSums(X_prev)
# Calculate ranks
step_ranks <- calculateTaskRank(TaskStepMat = X_step)
prev_ranks <- calculateTaskRank(TaskStepMat = X_prev)
# Calculate Correlation
rankCorr <- cor(prev_ranks, step_ranks, method = "spearman")
# Put in list
taskCorr[[(t / corrStep) - 1]] <- diag(rankCorr)
names(taskCorr)[(t / corrStep) - 1] <- paste0("Gen", t)
}
# Update previous step total matrix
X_prevTot <- X_tot
# Update previous step total matrix
X_prev <- X_step
}
}
# Calculate specialization of task performance
# from Gautrais et al. (2002)
for (col in 1:ncol(taskOverTime)) {
# Grab column of individual
t_prof <- taskOverTime[ , col ]
# Remove inactivity
t_prof <- paste(t_prof, collapse = "")
# Calculate transitions
t_prof <- gsub("1+", "1", t_prof)
t_prof <- gsub("2+", "2", t_prof)
t_prof <- gsub("0+", "", t_prof)
t_prof <- as.numeric(unlist(strsplit(as.character(t_prof), "")))
transitions <- lapply(2:length(t_prof), function(entry) {
a <- t_prof[entry] != t_prof[entry - 1]
})
C_i <- sum(unlist(transitions))
C_i <- C_i / (length(t_prof) - 1)
# Calulate specialization
F_i <- 1 - m * C_i
to_return <- data.frame(individual = paste0("v-", col),
n = n,
replicate = sim,
TransSpec = F_i)
groups_specialization <- rbind(groups_specialization, to_return)
}
# Calculate Entropy
entropy <- mutualEntropy(TotalStateMat = X_tot)
entropy <- transform(entropy, n = n, replicate = sim)
# Calculate total task distribution
# totalTaskDist <- X_tot / rowSums(X_tot)
totalTaskDist <- X_tot / gens
totalTaskDist <- transform(totalTaskDist, Inactive = gens - rowSums(X_tot), n = n, replicate = sim)
totalTaskDist$individual <- paste0("v-", 1:nrow(totalTaskDist))
# Create tasktally table
taskTally <- do.call("rbind", taskTally)
# Create tasktally table
stimMat <- transform(stimMat, n = n, replicate = sim)
# Create tasktally table
taskCorr <- transform(taskCorr, replicate = sim)
# Add total task distributions, entropy values, and graphs to lists
ens_taskDist[[sim]]  <- totalTaskDist
ens_entropy[[sim]]   <- entropy
ens_taskCorr[[sim]]  <- taskCorr
ens_taskTally[[sim]] <- taskTally
ens_taskStep[[sim]]  <- taskStep
ens_stim[[sim]]      <- stimMat
ens_taskOverTime[[sim]] <- as.data.frame(taskOverTime)
# Print simulation completed
print(paste0("DONE: N = ", n, ", Simulation ", sim))
}
# Calculate mean correlation for each n
runCorrs <- lapply(ens_taskCorr, function(x) {
# Unlist
runs <- do.call("rbind", x)
replicate <- runs[nrow(runs), ]
replicate <- unique(replicate)
runs <- runs[-nrow(runs), ]
# Calculate mean
runMean <- matrix(data = rep(NA, m), ncol =  m)
for (column in 1:m) {
runMean[ , column] <- mean(runs[ , column], na.rm = TRUE)
}
runMean <- cbind(runMean, replicate)
colnames(runMean) <- c("Task1", "Task2", "replicate")
return(runMean)
})
runCorrs <- do.call("rbind", runCorrs)
runCorrs <- transform(runCorrs, n = n)
# Add to list of lists
groups_taskDist[[i]]  <- ens_taskDist
groups_taskCorr[[i]]  <- runCorrs
groups_taskStep[[i]]  <- ens_taskStep
groups_taskTally[[i]] <- ens_taskTally
groups_stim[[i]]      <- ens_stim
groups_entropy[[i]]   <- ens_entropy
groups_taskOverTime[[i]] <- ens_taskOverTime
}
# trim out correlations for group size 1
if(1 %in% Ns) {
groups_taskCorr <- groups_taskCorr[-1]
}
####################
# Frequency of task not being performed
####################
noTaskPerf <- lapply(groups_taskTally, function(group_size) {
# Loop through replicates within group size
within_groupTaskPerf <- lapply(group_size, function(replicate) {
# Get basics and counts of instances in which there isn't anyone performing task
to_return <- data.frame(n = unique(replicate$n),
replicate = unique(replicate$replicate),
Set = paste0(unique(replicate$n), "-", unique(replicate$replicate)),
noTask1 = sum(replicate$Task1 == 0),
noTask2 = sum(replicate$Task2 == 0))
#  Quantify length of no-performance bouts
for (task in c("Task1", "Task2")) {
bout_lengths <- rle(replicate[ , task])
bout_lengths <- as.data.frame(do.call("cbind", bout_lengths))
bout_lengths <- bout_lengths %>%
filter(values == 0)
avg_nonPerformance <- mean(bout_lengths$lengths)
if(task == "Task1") {
to_return$noTask1Length = avg_nonPerformance
}
else {
to_return$noTask2Length = avg_nonPerformance
}
}
# Get averages
to_return <- to_return %>%
mutate(noTaskAvg = (noTask1 + noTask2) / 2,
noTaskLengthAvg = (noTask1Length + noTask2Length) / 2)
# Return
return(to_return)
})
# Bind and return
within_groupTaskPerf <- do.call("rbind", within_groupTaskPerf)
return(within_groupTaskPerf)
})
# Bind
noTaskPerf <- do.call("rbind", noTaskPerf)
# Plot
gg_noTask <- ggplot(data = noTaskPerf, aes(x = n, y = noTask1)) +
geom_point() +
theme_classic() +
scale_x_continuous(breaks = unique(noTaskPerf$n)) +
scale_y_continuous(limits = c(0, 6800)) +
xlab("Group Size") +
ylab("Instances of No Task 1 Performance")
# ylab("Avg. Length of No Task 1 Performance")
gg_noTask
####################
# Frequency of task not being performed vs. specialization
####################
# Load specialization
taskCorrTot <- do.call("rbind", groups_taskCorr)
taskCorrTot <- taskCorrTot %>%
mutate(TaskMean = (Task1 + Task2) / 2)
taskCorrTot <- taskCorrTot %>%
mutate(Set = paste0(n, "-", replicate)) %>%
select(n, TaskMean, Set)
# Merge
merged_specperf <- merge(taskCorrTot, noTaskPerf, by = c("Set", "n"))
# Plot
gg_specPerf <- ggplot(data = merged_specperf) +
geom_point(aes(x = TaskMean, y = noTask1, colour = as.factor(n))) +
theme_classic() +
facet_wrap(~n, scales = "free") +
scale_color_manual(values = palette) +
theme(legend.position = "none") +
ylab("Instances of Task 1 Neglect") +
xlab("Rank Correlation")
gg_specPerf
# Plot
gg_specPerf <- ggplot(data = merged_specperf) +
geom_point(aes(x = TaskMean, y = noTask1, colour = as.factor(n))) +
theme_classic() +
facet_wrap(~n, scales = "free") +
# scale_color_manual(values = palette) +
theme(legend.position = "none") +
ylab("Instances of Task 1 Neglect") +
xlab("Rank Correlation")
gg_specPerf
####################
# Compare entropies
####################
# Unlist
entropy <- unlist(groups_entropy, recursive = FALSE)
entropy <- do.call("rbind", entropy)  %>%
mutate(set = paste(n, replicate, sep = "-"))%>%
select(-Dsym, -Dyx) %>%
filter(n != 1)
merged_specperf <- merge(merged_specperf, entropy, by = c("Set", "n"))
####################
# Compare entropies
####################
# Unlist
entropy <- unlist(groups_entropy, recursive = FALSE)
entropy <- do.call("rbind", entropy)  %>%
mutate(Set = paste(n, replicate, sep = "-"))%>%
select(-Dsym, -Dyx) %>%
filter(n != 1)
merged_specperf <- merge(merged_specperf, entropy, by = c("Set", "n"))
name(merged_specperf)
names(merged_specperf)
# Plot
gg_specPerf <- ggplot(data = merged_specperf) +
geom_point(aes(x = Dxy, y = noTask1, colour = as.factor(n))) +
theme_classic() +
facet_wrap(~n, scales = "free") +
# scale_color_manual(values = palette) +
theme(legend.position = "none") +
ylab("Instances of Task 1 Neglect") +
xlab("Rank Correlation")
gg_specPerf
rm(list = ls())
source("scripts/__Util__MASTER.R")
source("scripts/3_PrepPlotExperimentData.R")
load("output/__RData/MSrevision_FixedDelta06Sigma01Eta7100reps.Rdata")
# Set variable
filename <- "Fixed_Delta06Sigma01Eta7"
# Palette without single individuals
palette <- c("#F00924", "#F7A329", "#FDD545", "#027C2C", "#1D10F9", "#4C0E78", "#bdbdbd", "#525252")
####################
# Frequency of task not being performed
####################
noTaskPerf <- lapply(groups_taskTally, function(group_size) {
# Loop through replicates within group size
within_groupTaskPerf <- lapply(group_size, function(replicate) {
# Get basics and counts of instances in which there isn't anyone performing task
to_return <- data.frame(n = unique(replicate$n),
replicate = unique(replicate$replicate),
Set = paste0(unique(replicate$n), "-", unique(replicate$replicate)),
noTask1 = sum(replicate$Task1 == 0),
noTask2 = sum(replicate$Task2 == 0))
#  Quantify length of no-performance bouts
for (task in c("Task1", "Task2")) {
bout_lengths <- rle(replicate[ , task])
bout_lengths <- as.data.frame(do.call("cbind", bout_lengths))
bout_lengths <- bout_lengths %>%
filter(values == 0)
avg_nonPerformance <- mean(bout_lengths$lengths)
if(task == "Task1") {
to_return$noTask1Length = avg_nonPerformance
}
else {
to_return$noTask2Length = avg_nonPerformance
}
}
# Get averages
to_return <- to_return %>%
mutate(noTaskAvg = (noTask1 + noTask2) / 2,
noTaskLengthAvg = (noTask1Length + noTask2Length) / 2)
# Return
return(to_return)
})
# Bind and return
within_groupTaskPerf <- do.call("rbind", within_groupTaskPerf)
return(within_groupTaskPerf)
})
# Bind
noTaskPerf <- do.call("rbind", noTaskPerf)
# Plot
gg_noTask <- ggplot(data = noTaskPerf, aes(x = n, y = noTask1)) +
geom_point() +
theme_classic() +
scale_x_continuous(breaks = unique(noTaskPerf$n)) +
scale_y_continuous(limits = c(0, 6800)) +
xlab("Group Size") +
ylab("Instances of No Task 1 Performance")
# ylab("Avg. Length of No Task 1 Performance")
gg_noTask
####################
# Frequency of task not being performed vs. specialization
####################
# Load specialization
taskCorrTot <- do.call("rbind", groups_taskCorr)
taskCorrTot <- taskCorrTot %>%
mutate(TaskMean = (Task1 + Task2) / 2)
taskCorrTot <- taskCorrTot %>%
mutate(Set = paste0(n, "-", replicate)) %>%
select(n, TaskMean, Set)
# Merge
merged_specperf <- merge(taskCorrTot, noTaskPerf, by = c("Set", "n"))
# Plot
####################
# Compare entropies
####################
# Unlist
entropy <- unlist(groups_entropy, recursive = FALSE)
entropy <- do.call("rbind", entropy)  %>%
mutate(Set = paste(n, replicate, sep = "-"))%>%
select(-Dsym, -Dyx) %>%
filter(n != 1)
merged_specperf <- merge(merged_specperf, entropy, by = c("Set", "n"))
# Plot
gg_specPerf <- ggplot(data = merged_specperf) +
geom_point(aes(x = Dxy, y = noTask1, colour = as.factor(n))) +
theme_classic() +
facet_wrap(~n, scales = "free") +
# scale_color_manual(values = palette) +
theme(legend.position = "none") +
ylab("Instances of Task 1 Neglect") +
xlab("Rank Correlation")
gg_specPerf
taskDist <- unlist(groups_taskDist, recursive = FALSE)
taskDistTot <- do.call("rbind", taskDist)
taskDistSpec <- taskDistTot %>%
mutate(Active = Task1 + Task2) %>%
merge(groups_specialization) %>%
filter(n > 1) %>%
mutate(groupsize = factor(paste0("Group size ", n),
levels = c("Group size 2", "Group size 4", "Group size 6", "Group size 8", "Group size 12", "Group size 16")))
gg_actspec <- ggplot(data = taskDistSpec, aes(x = Active, y = TransSpec, colour = groupsize)) +
geom_hline(aes(yintercept = 0),
colour = "grey30",
size = 0.25) +
geom_point(alpha = 0.5,
size = 0.8,
stroke = 0) +
theme_bw() +
scale_colour_manual(name = "Group Size",
values = palette) +
scale_y_continuous(limits = c(-0.2, 1)) +
scale_x_continuous(breaks = seq(0, 1, 0.2)) +
theme(legend.position = "none") +
xlab("Activity level") +
ylab("Task consistency") +
theme(legend.position = "none",
legend.title = element_text(size = 7),
legend.key.height = unit(0.3, "cm"),
legend.key.width= unit(0.4, "cm"),
legend.margin =  margin(t = 0.1, r = 0.1, b = 0.1, l = 0.1, "cm"),
legend.text = element_text(size = 6),
axis.text = element_text(size = 8),
axis.title = element_text(size = 10),
axis.ticks = element_line(size = 0.5),
panel.border = element_rect(fill = NA, size = 1),
panel.grid = element_blank(),
strip.text = element_text(size = 8, face = "italic"),
strip.background = element_rect(fill = NA, colour = NA),
panel.spacing = unit(0.5, "cm")) +
facet_wrap(~ groupsize)
gg_actspec
# Unlist
entropy <- unlist(groups_entropy, recursive = FALSE)
entropy <- do.call("rbind", entropy)  %>%
mutate(set = paste(n, replicate, sep = "-"))
# Unlist
taskCorrTot <- do.call("rbind", groups_taskCorr)
taskCorrTot <- taskCorrTot %>%
mutate(TaskMean = (Task1 + Task2) / 2) %>%
mutate(set = paste(n, replicate, sep = "-"))%>%
select(-Task1, -Task2)
# Speclialization vs Entropy at colony level
entropy <- entropy %>%
mutate(colony = paste0(n, "-", replicate)) %>%
group_by(colony) %>%
summarize(Dsym = mean(Dsym),
Dyx = mean(Dyx),
Dxy = mean(Dxy))
taskEntrCorr <- taskCorrTot %>%
mutate(colony = paste0(n, "-", replicate)) %>%
merge(entropy) %>%
select(colony, n, replicate, TaskMean, Dxy) %>%
mutate(groupsize = factor(paste0("n = ", n),
levels = c("n = 2", "n = 4", "n = 6", "n = 8", "n = 12", "n = 16")))
palette <- c("#F00924", "#F7A329", "#FDD545", "#027C2C", "#1D10F9", "#4C0E78", "#bdbdbd", "#525252")
gg_entrcorr <- ggplot(data = taskEntrCorr, aes(x = Dxy, y = TaskMean, col = groupsize)) +
geom_hline(data = taskCorrTot,
aes(yintercept = 0),
colour = "grey30",
size = 0.25) +
geom_point(alpha = 0.5,
size = 0.2) +
theme_bw() +
xlab("Task Entropy") +
ylab("Rank Correlation") +
scale_colour_manual(name = "Group Size",
values = palette) +
scale_x_continuous(limits = c(0, 0.4),
breaks = seq(0, 0.4, 0.2)) +
scale_y_continuous(limits = c(-0.5, 1)) +
theme(legend.position = "none",
legend.title = element_text(size = 7),
legend.key.height = unit(0.3, "cm"),
legend.key.width= unit(0.4, "cm"),
legend.margin =  margin(t = 0.1, r = 0.1, b = 0.1, l = 0.1, "cm"),
legend.text = element_text(size = 6),
axis.text = element_text(size = 8),
axis.title = element_text(size = 10),
axis.ticks = element_line(size = 0.5),
panel.border = element_rect(fill = NA, size = 1),
panel.grid = element_blank(),
strip.text = element_text(size = 7, face = "italic"),
strip.background = element_rect(fill = NA, colour = NA),
panel.spacing = unit(0.5, "cm")) +
facet_wrap(~ groupsize)
gg_entrcorr
# Plot
gg_specPerf <- ggplot(data = merged_specperf) +
geom_point(aes(x = Dxy, y = noTask1, colour = as.factor(n))) +
theme_classic() +
facet_wrap(~n, scales = "free") +
scale_color_manual(values = palette) +
theme(legend.position = "none") +
ylab("Instances of Task 1 Neglect") +
xlab("Rank Correlation")
gg_specPerf
load("output/__RData/MSrevision_FixedDelta06Sigma01Eta7100reps.Rdata")
####################
# Compare entropies
####################
# Unlist
entropy <- unlist(groups_entropy, recursive = FALSE)
entropy <- do.call("rbind", entropy)  %>%
mutate(Set = paste(n, replicate, sep = "-"))%>%
select(-Dsym, -Dyx) %>%
filter(n != 1)
####################
# Frequency of task not being performed
####################
noTaskPerf <- lapply(groups_taskTally, function(group_size) {
# Loop through replicates within group size
within_groupTaskPerf <- lapply(group_size, function(replicate) {
# Get basics and counts of instances in which there isn't anyone performing task
to_return <- data.frame(n = unique(replicate$n),
replicate = unique(replicate$replicate),
Set = paste0(unique(replicate$n), "-", unique(replicate$replicate)),
noTask1 = sum(replicate$Task1 == 0),
noTask2 = sum(replicate$Task2 == 0))
#  Quantify length of no-performance bouts
for (task in c("Task1", "Task2")) {
bout_lengths <- rle(replicate[ , task])
bout_lengths <- as.data.frame(do.call("cbind", bout_lengths))
bout_lengths <- bout_lengths %>%
filter(values == 0)
avg_nonPerformance <- mean(bout_lengths$lengths)
if(task == "Task1") {
to_return$noTask1Length = avg_nonPerformance
}
else {
to_return$noTask2Length = avg_nonPerformance
}
}
# Get averages
to_return <- to_return %>%
mutate(noTaskAvg = (noTask1 + noTask2) / 2,
noTaskLengthAvg = (noTask1Length + noTask2Length) / 2)
# Return
return(to_return)
})
# Bind and return
within_groupTaskPerf <- do.call("rbind", within_groupTaskPerf)
return(within_groupTaskPerf)
})
# Bind
noTaskPerf <- do.call("rbind", noTaskPerf)
# Plot
gg_noTask <- ggplot(data = noTaskPerf, aes(x = n, y = noTask1)) +
geom_point() +
theme_classic() +
scale_x_continuous(breaks = unique(noTaskPerf$n)) +
scale_y_continuous(limits = c(0, 6800)) +
xlab("Group Size") +
ylab("Instances of No Task 1 Performance")
# ylab("Avg. Length of No Task 1 Performance")
gg_noTask
####################
# Frequency of task not being performed vs. specialization
####################
# Load specialization
taskCorrTot <- do.call("rbind", groups_taskCorr)
taskCorrTot <- taskCorrTot %>%
mutate(TaskMean = (Task1 + Task2) / 2)
taskCorrTot <- taskCorrTot %>%
mutate(Set = paste0(n, "-", replicate)) %>%
select(n, TaskMean, Set)
# Merge
merged_specperf <- merge(taskCorrTot, noTaskPerf, by = c("Set", "n"))
merged_specperf <- merge(merged_specperf, entropy, by = c("Set", "n"))
# Plot
gg_specPerf <- ggplot(data = merged_specperf) +
geom_point(aes(x = Dxy, y = noTask1, colour = as.factor(n))) +
theme_classic() +
facet_wrap(~n, scales = "free") +
scale_color_manual(values = palette) +
theme(legend.position = "none") +
ylab("Instances of Task 1 Neglect") +
xlab("Rank Correlation")
gg_specPerf
# Plot
gg_specPerf <- ggplot(data = merged_specperf) +
geom_point(aes(x = Dxy, y = noTask1, colour = as.factor(n))) +
theme_classic() +
facet_wrap(~n, scales = "free") +
scale_color_manual(values = palette) +
theme(legend.position = "none") +
ylab("Instances of Task 1 Neglect") +
xlab("DOL Entropy")
gg_specPerf
