<<<<<<< HEAD
<<<<<<< HEAD
y = noTaskAvgNorm),
# colour = "black",
size = 0.1,
stroke = 0.4) +
theme_classic() +
theme(legend.position = "none") +
ylab("Normalized task neglect") +
xlab("Norm. specialization") +
scale_y_continuous(breaks = seq(0, 1, 0.2),
expand = c(0, 0.01)) +
scale_x_continuous(breaks = seq(0, 1, 0.5),
expand = c(0, 0.03)) +
scale_color_manual(values = palette) +
theme(axis.text.y = element_text(size = 6, margin = margin(0, 5, 0, -4), color = "black"),
axis.text.x = element_text(size = 6, margin = margin(5, 0, -4, 0), color = "black"),
axis.title = element_text(size = 7, margin = margin(0, 0, 0, 0)),
axis.ticks.length = unit(-0.06, "cm"),
axis.ticks = element_line(colour = "black", size = 0.3),
axis.line = element_line(size = 0.3),
plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "mm"))
gg_specPerfNorm
# svg("output/MSFigures/TaskNeglect_WithinGroup_Normalized_Color.svg",  width = 1.45, height = 2.068)
ggsave("output/MSFigures/TaskNeglect_WithinGroup_Normalized_Color_OneColumn.svg",  width = 22.5, height = 45, units = "mm")
ggsave("output/MSFigures/TaskNeglect_WithinGroup_Normalized_Color.svg",  width = 23.5, height = 30, units = "mm")
ggsave("output/MSFigures/TaskNeglect_WithinGroup_Normalized_Color_threeperrow.svg",  width = 40, height = 35, units = "mm")
ggsave("output/MSFigures/TaskNeglect_WithinGroup_Normalized_Color_threeperrow.svg",  width = 45, height = 35, units = "mm")
ggsave("output/MSFigures/TaskNeglectCombined_ThreePerRow.svg", width = 45, height = 35, units = 'mm')
# Plot
gg_noTask <- ggplot(data = neglectSum) +
geom_errorbar(aes(x = n,
ymin = TaskNegelectMean - TaskNegelectSE,
ymax = TaskNegelectMean + TaskNegelectSE),
colour = "black",
size = 0.25,
width = 0.1) +
geom_point(aes(x = n, y = TaskNegelectMean),
colour = "black",
size = 0.7) +
theme_classic() +
labs(x = "Group size",
y = "Avg. task neglect") +
scale_x_continuous(breaks = unique(neglectSum$n),
labels = c(1, "", 4, "", 8, 12, 16)) +
scale_y_continuous(breaks = seq(0, 1, 0.1),
limits = c(0, 0.825),
expand = c(0, 0)) +
theme(legend.position = "none",
legend.justification = c(1, 1),
legend.title = element_blank(),
legend.key.height = unit(0.3, "cm"),
legend.key.width= unit(0.4, "cm"),
legend.margin =  margin(t = 0, r = 0, b = 0, l = -0.2, "cm"),
legend.text = element_text(size = 6),
legend.text.align = 0,
# legend.box.background = element_rect(),
axis.text.y = element_text(size = 6, margin = margin(t = 0, r =  5, b =  0, l = -4), color = "black"),
axis.text.x = element_text(size = 6, margin = margin(5, 0, -4, 0), color = "black"),
axis.title = element_text(size = 7, margin = margin(0, 0, 0, 0)),
axis.ticks.length = unit(-0.06, "cm"),
axis.ticks = element_line(colour = "black", size = 0.3),
axis.line = element_line(size = 0.3),
plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "mm"))
ggsave("output/MSFigures/TaskNeglectCombined_ThreePerRow.svg", width = 45, height = 35, units = 'mm')
gg_specPerfNorm <- ggplot(data = merged_specperf) +
geom_point(aes(x = TaskMeanNorm,
colour = as.factor(n),
y = noTaskAvgNorm),
# colour = "black",
size = 0.1,
stroke = 0.4) +
theme_classic() +
theme(legend.position = "none") +
ylab("Normalized task neglect") +
xlab("Norm. specialization") +
scale_y_continuous(breaks = seq(0, 1, 0.2),
expand = c(0, 0.0)) +
scale_x_continuous(breaks = seq(0, 1, 0.5),
expand = c(0, 0.0)) +
scale_color_manual(values = palette) +
theme(axis.text.y = element_text(size = 6, margin = margin(0, 5, 0, -4), color = "black"),
axis.text.x = element_text(size = 6, margin = margin(5, 0, -4, 0), color = "black"),
axis.title = element_text(size = 7, margin = margin(0, 0, 0, 0)),
axis.ticks.length = unit(-0.06, "cm"),
axis.ticks = element_line(colour = "black", size = 0.3),
axis.line = element_line(size = 0.3),
plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "mm"))
gg_specPerfNorm
ggsave("output/MSFigures/TaskNeglect_WithinGroup_Normalized_Color_threeperrow.svg",  width = 45, height = 35, units = "mm")
gg_specPerfNorm <- ggplot(data = merged_specperf) +
geom_point(aes(x = TaskMeanNorm,
colour = as.factor(n),
y = noTaskAvgNorm),
# colour = "black",
size = 0.1,
stroke = 0.4) +
theme_classic() +
theme(legend.position = "none") +
ylab("Normalized task neglect") +
xlab("Norm. specialization") +
scale_y_continuous(breaks = seq(0, 1, 0.2),
expand = c(0, 0.01)) +
scale_x_continuous(breaks = seq(0, 1, 0.5),
expand = c(0, 0.01)) +
scale_color_manual(values = palette) +
theme(axis.text.y = element_text(size = 6, margin = margin(0, 5, 0, -4), color = "black"),
axis.text.x = element_text(size = 6, margin = margin(5, 0, -4, 0), color = "black"),
axis.title = element_text(size = 7, margin = margin(0, 0, 0, 0)),
axis.ticks.length = unit(-0.06, "cm"),
axis.ticks = element_line(colour = "black", size = 0.3),
axis.line = element_line(size = 0.3),
plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "mm"))
ggsave("output/MSFigures/TaskNeglect_WithinGroup_Normalized_Color_threeperrow.svg",  width = 45, height = 35, units = "mm")
rm(list = ls())
source("scripts/__Util__MASTER.R")
source("scripts/3_PrepPlotExperimentData.R")
min_rmsd <- read.csv(file = "data/minRMSD.csv", header = TRUE)
min_rmsd_summary <- min_rmsd %>%
group_by(GroupSize) %>%
summarise(MeanMinRMSD = mean(minRMSD),
MeanMinRMSDSE = ( sd(minRMSD) / sqrt(length(minRMSD))))
blank_row <- data.frame("colonyID" = 'blah', "GroupSize" = 1.0, "minRMSD" = NA)
min_rmsd <- rbind(min_rmsd, blank_row)
gg_RMSD <- ggplot() +
geom_point(data = min_rmsd,
aes(x = GroupSize, y = minRMSD),
col = "grey60",
size = 0.4,
shape = 8,
stroke = 0.2) +
geom_errorbar(data = min_rmsd_summary,
aes(x = GroupSize,
ymin = MeanMinRMSD - MeanMinRMSDSE,
ymax = MeanMinRMSD + MeanMinRMSDSE),
colour = "black",
size = 0.3,
width = 0) +
geom_point(data = min_rmsd_summary,
aes(x = GroupSize, y = MeanMinRMSD),
size = 0.7) +
theme_classic() +
xlab("Group Size") +
ylab("Min. RMSD (mm)") +
scale_y_continuous(breaks = seq(9, 19, 1),
expand = c(0, 0.05),
labels = c('', '10', '', '12', '', '14', '', '16', '', '18', '')) +
scale_x_continuous(breaks = c(0, 2, 4, 6, 8, 12, 16),
expand = c(0, 0.0),
labels = c('', '2', '', '6', '', '12', '16')) +
scale_color_manual(values = palette) +
theme(axis.text.y = element_text(size = 6, margin = margin(0, 5, 0, -4), color = "black"),
axis.text.x = element_text(size = 6, margin = margin(5, 0, -4, 0), color = "black"),
axis.title = element_text(size = 7, margin = margin(0, 0, 0, 0)),
axis.ticks.length = unit(-0.06, "cm"),
axis.ticks = element_line(colour = "black", size = 0.3),
axis.line = element_line(size = 0.3),
plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "mm"))
gg_RMSD
ggsave("output/MSFigures/MinRMSDFigure.svg",  width = 23.5, height = 30, units = "mm")
ggsave("output/MSFigures/MinRMSDFigure_threeperrow.svg", width = 45, height = 35, units = "mm")
rm(list = ls())
source("scripts/__Util__MASTER.R")
source("scripts/3_PrepPlotExperimentData.R")
load("output/__RData/FixedDelta06Sigma01Eta7100reps.Rdata")
# Frequency of no task being performed
noTaskPerf <- lapply(groups_taskTally, function(group_size) {
# Loop through replicates within group size
within_groupTaskPerf <- lapply(group_size, function(replicate) {
# Get basics and counts of instances in which there isn't anyone performing task
to_return <- data.frame(n = unique(replicate$n),
replicate = unique(replicate$replicate),
Set = paste0(unique(replicate$n), "-", unique(replicate$replicate)),
noTask1 = sum(replicate$Task1 == 0),
noTask2 = sum(replicate$Task2 == 0))
#  Quantify length of no-performance bouts
for (task in c("Task1", "Task2")) {
bout_lengths <- rle(replicate[ , task])
bout_lengths <- as.data.frame(do.call("cbind", bout_lengths))
bout_lengths <- bout_lengths %>%
filter(values == 0)
avg_nonPerformance <- mean(bout_lengths$lengths)
if(task == "Task1") {
to_return$noTask1Length = avg_nonPerformance
}
else {
to_return$noTask2Length = avg_nonPerformance
}
}
# Get averages
to_return <- to_return %>%
mutate(noTaskAvg = (noTask1 + noTask2) / 2,
noTaskLengthAvg = (noTask1Length + noTask2Length) / 2)
# Return
return(to_return)
})
# Bind and return
within_groupTaskPerf <- do.call("rbind", within_groupTaskPerf)
return(within_groupTaskPerf)
})
# Bind
noTaskPerf <- do.call("rbind", noTaskPerf)
# Summarise
neglectSum <- noTaskPerf %>%
group_by(n) %>%
mutate(noTaskAvg = (noTask1 + noTask2) / 2 ) %>%
summarise(Task1NegelectMean = mean(noTask1, na.rm = TRUE) / 10000,
Task1NegelectSE = ( sd(noTask1) / sqrt(length(noTask1)) ) / 1000,
Task2NegelectMean = mean(noTask2, na.rm = TRUE) / 10000,
Task2NegelectSE = ( sd(noTask2) / sqrt(length(noTask2)) ) / 10000,
TaskNegelectMean = mean(noTaskAvg, na.rm = TRUE) / 10000,
TaskNegelectSE = ( sd(noTaskAvg) / sqrt(length(noTaskAvg)) ) / 10000)
# Plot
gg_noTask <- ggplot(data = neglectSum) +
geom_errorbar(aes(x = n,
ymin = TaskNegelectMean - TaskNegelectSE,
ymax = TaskNegelectMean + TaskNegelectSE),
colour = "black",
size = 0.25,
width = 0.1) +
geom_point(aes(x = n, y = TaskNegelectMean),
colour = "black",
size = 0.7) +
theme_classic() +
labs(x = "Group size",
y = "Avg. task neglect") +
scale_x_continuous(breaks = unique(neglectSum$n),
labels = c(1, "", 4, "", 8, 12, 16)) +
scale_y_continuous(breaks = seq(0, 1, 0.1),
limits = c(0, 0.825),
expand = c(0, 0)) +
theme(legend.position = "none",
legend.justification = c(1, 1),
legend.title = element_blank(),
legend.key.height = unit(0.3, "cm"),
legend.key.width= unit(0.4, "cm"),
legend.margin =  margin(t = 0, r = 0, b = 0, l = -0.2, "cm"),
legend.text = element_text(size = 6),
legend.text.align = 0,
# legend.box.background = element_rect(),
axis.text.y = element_text(size = 6, margin = margin(t = 0, r =  5, b =  0, l = -4), color = "black"),
axis.text.x = element_text(size = 6, margin = margin(5, 0, -4, 0), color = "black"),
axis.title = element_text(size = 7, margin = margin(0, 0, 0, 0)),
axis.ticks.length = unit(-0.06, "cm"),
axis.ticks = element_line(colour = "black", size = 0.3),
axis.line = element_line(size = 0.3),
plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "mm"))
ggsave("output/MSFigures/TaskNeglectCombined.svg",  width = 23.5, height = 29.5, units = "mm")
# Plot
gg_noTask <- ggplot(data = neglectSum) +
geom_errorbar(aes(x = n,
ymin = TaskNegelectMean - TaskNegelectSE,
ymax = TaskNegelectMean + TaskNegelectSE),
colour = "black",
size = 0.25,
width = 0.1) +
geom_point(aes(x = n, y = TaskNegelectMean),
colour = "black",
size = 0.7) +
theme_classic() +
labs(x = "Group size",
y = "Avg. task neglect") +
scale_x_continuous(breaks = unique(neglectSum$n),
labels = c(1, "", 4, "", 8, 12, 16)) +
scale_y_continuous(breaks = seq(0, 1, 0.1),
labels = c("0.0", "", "0.2", "", "0.4", "", "0.6", "", "0.8")
limits = c(0, 0.825),
expand = c(0, 0)) +
theme(legend.position = "none",
legend.justification = c(1, 1),
legend.title = element_blank(),
legend.key.height = unit(0.3, "cm"),
legend.key.width= unit(0.4, "cm"),
legend.margin =  margin(t = 0, r = 0, b = 0, l = -0.2, "cm"),
legend.text = element_text(size = 6),
legend.text.align = 0,
# legend.box.background = element_rect(),
axis.text.y = element_text(size = 6, margin = margin(t = 0, r =  5, b =  0, l = -4), color = "black"),
axis.text.x = element_text(size = 6, margin = margin(5, 0, -4, 0), color = "black"),
axis.title = element_text(size = 7, margin = margin(0, 0, 0, 0)),
axis.ticks.length = unit(-0.06, "cm"),
axis.ticks = element_line(colour = "black", size = 0.3),
axis.line = element_line(size = 0.3),
plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "mm"))
ggsave("output/MSFigures/TaskNeglectCombined.svg",  width = 23.5, height = 29.5, units = "mm")
# Plot
gg_noTask <- ggplot(data = neglectSum) +
geom_errorbar(aes(x = n,
ymin = TaskNegelectMean - TaskNegelectSE,
ymax = TaskNegelectMean + TaskNegelectSE),
colour = "black",
size = 0.25,
width = 0.1) +
geom_point(aes(x = n, y = TaskNegelectMean),
colour = "black",
size = 0.7) +
theme_classic() +
labs(x = "Group size",
y = "Avg. task neglect") +
scale_x_continuous(breaks = unique(neglectSum$n),
labels = c(1, "", 4, "", 8, 12, 16)) +
scale_y_continuous(breaks = seq(0, 1, 0.1),
labels = c("0.0", "", "0.2", "", "0.4", "", "0.6", "", "0.8"),
limits = c(0, 0.825),
expand = c(0, 0)) +
theme(legend.position = "none",
legend.justification = c(1, 1),
legend.title = element_blank(),
legend.key.height = unit(0.3, "cm"),
legend.key.width= unit(0.4, "cm"),
legend.margin =  margin(t = 0, r = 0, b = 0, l = -0.2, "cm"),
legend.text = element_text(size = 6),
legend.text.align = 0,
# legend.box.background = element_rect(),
axis.text.y = element_text(size = 6, margin = margin(t = 0, r =  5, b =  0, l = -4), color = "black"),
axis.text.x = element_text(size = 6, margin = margin(5, 0, -4, 0), color = "black"),
axis.title = element_text(size = 7, margin = margin(0, 0, 0, 0)),
axis.ticks.length = unit(-0.06, "cm"),
axis.ticks = element_line(colour = "black", size = 0.3),
axis.line = element_line(size = 0.3),
plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "mm"))
# Plot
gg_noTask <- ggplot(data = neglectSum) +
geom_errorbar(aes(x = n,
ymin = TaskNegelectMean - TaskNegelectSE,
ymax = TaskNegelectMean + TaskNegelectSE),
colour = "black",
size = 0.25,
width = 0.1) +
geom_point(aes(x = n, y = TaskNegelectMean),
colour = "black",
size = 0.7) +
theme_classic() +
labs(x = "Group size",
y = "Avg. task neglect") +
scale_x_continuous(breaks = unique(neglectSum$n),
labels = c(1, "", 4, "", 8, 12, 16)) +
scale_y_continuous(breaks = seq(0, 1, 0.1),
labels = c("0.0", "", "0.2", "", "0.4", "", "0.6", "", "0.8", "", ""),
limits = c(0, 0.825),
expand = c(0, 0)) +
theme(legend.position = "none",
legend.justification = c(1, 1),
legend.title = element_blank(),
legend.key.height = unit(0.3, "cm"),
legend.key.width= unit(0.4, "cm"),
legend.margin =  margin(t = 0, r = 0, b = 0, l = -0.2, "cm"),
legend.text = element_text(size = 6),
legend.text.align = 0,
# legend.box.background = element_rect(),
axis.text.y = element_text(size = 6, margin = margin(t = 0, r =  5, b =  0, l = -4), color = "black"),
axis.text.x = element_text(size = 6, margin = margin(5, 0, -4, 0), color = "black"),
axis.title = element_text(size = 7, margin = margin(0, 0, 0, 0)),
axis.ticks.length = unit(-0.06, "cm"),
axis.ticks = element_line(colour = "black", size = 0.3),
axis.line = element_line(size = 0.3),
plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "mm"))
ggsave("output/MSFigures/TaskNeglectCombined.svg",  width = 23.5, height = 29.5, units = "mm")
rm(list = ls())
source("scripts/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
##### Delta 06 #####
# load
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExplorationEXTRA.Rdata")
improve1 <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExplorationEXTRA2.Rdata")
improve2 <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExploration.Rdata")
improve <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
improve06 <- rbind(improve, improve1, improve2)
rm(improve, improve1, improve2)
# Filter to size
improve06 <- improve06 %>%
filter(!sigma %in% c(0.075, 0.125, 0.175, 0.225, 0.275, 0.325))
##### Absolute Slope #####
# Colors
myPalette <- colorRampPalette(brewer.pal(6, "YlOrRd"))
colPal <- c(myPalette(6), "#800026")
# Fit surface
spec.loess <- loess(Increase ~ sigma * threshSlope, data = improve06, degree = 2, span = 0.1)
spec.fit <- expand.grid(list(sigma = seq(0, max(improve06$sigma), (max(improve06$sigma) - min(improve06$sigma)) / 1000),
threshSlope = seq(1, max(improve06$threshSlope), (max(improve06$threshSlope) - min(improve06$threshSlope)) / 1000)))
z <- predict(spec.loess, newdata = spec.fit)
spec.fit$spec <- as.numeric(z)
# Approximated +/- 10% of experimental data
# Experimental slope: 0.5915000 - 0.2663750 = 0.325125
spec.fit$CloseIncrease <- ifelse(spec.fit$spec >= 0.2926124 & spec.fit$spec <= 0.3576374, 0.5, 0)
# Graph
gg_abslope <- ggplot() +
# geom_raster(data = improve06,
#             aes(x = sigma,
#                 y = threshSlope,
#                 fill = Increase)) +
geom_tile(data = improve06,
aes(x = sigma,
y = threshSlope,
fill = Increase,
color = Increase)) +
stat_contour(data = spec.fit,
aes(x = sigma,
y = threshSlope,
z = spec),
size = 0.35,
colour = "white",
breaks = c(0.2926124)) +
stat_contour(data = spec.fit,
aes(x = sigma,
y = threshSlope,
z = spec),
size = 0.35,
colour = "white",
linetype = "dashed",
breaks = c(0.3576374)) +
theme_bw() +
scale_x_continuous(expand = c(0, -0.002)) +
scale_y_continuous(expand = c(0, -0.2), breaks = c(1, seq(10, 30, 10))) +
scale_fill_gradientn(name = "Specialization\nIncrease",
colors = colPal,
breaks = seq(0, 0.5, 0.1),
colours = colPal,
limits = c(0, 0.5),
oob = squish) +
scale_colour_gradientn(name = "Specialization\nIncrease",
colors = colPal,
breaks = seq(0, 0.5, 0.1),
colours = colPal,
limits = c(0, 0.5),
oob = squish) +
xlab(expression(sigma)) +
ylab(expression(eta)) +
theme(legend.position = "none",
# legend.key.height = unit(0.5, "cm"),
legend.key.height = unit(0.195, "npc"),
legend.key.width= unit(0.2, "cm"),
legend.key = element_rect(colour = "black", size = 0.5),
legend.margin =  margin(t = 0, r = 0, b = 0, l = -0.2, "cm"),
legend.text = element_text(size = 6),
legend.title = element_blank(),
axis.text.y = element_text(size = 6, margin = margin(t = 0, r = 3, b = 0, l = -5), color = "black"),
axis.text.x = element_text(size = 6, margin = margin(3, 0, -4, 0), color = "black"),
axis.title = element_text(size = 9, margin = margin(0, 0, 0, 0)),
plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "mm"),
axis.ticks.length = unit(0, "cm"),
panel.border = element_rect(colour = "black"))
gg_abslope
ggsave("output/MSFigures/ParameterSpaceDelta06wContour.svg", width = 50, height = 38.2, units = 'mm')
ggsave("output/MSFigures/ParameterSpaceDelta06wContour.svg", width = 50, height = 38.4, units = 'mm')
ggsave("output/MSFigures/ParameterSpaceDelta06wContour.svg", width = 50, height = 38.5, units = 'mm')
rm(list = ls())
source("scripts/__Util__MASTER.R")
source("scripts/3_PrepPlotExperimentData.R")
min_rmsd <- read.csv(file = "data/minRMSD.csv", header = TRUE)
min_rmsd_summary <- min_rmsd %>%
group_by(GroupSize) %>%
summarise(MeanMinRMSD = mean(minRMSD),
MeanMinRMSDSE = ( sd(minRMSD) / sqrt(length(minRMSD))))
blank_row <- data.frame("colonyID" = 'blah', "GroupSize" = 1.0, "minRMSD" = NA)
min_rmsd <- rbind(min_rmsd, blank_row)
gg_RMSD <- ggplot() +
geom_point(data = min_rmsd,
aes(x = GroupSize, y = minRMSD),
col = "grey60",
size = 0.4,
shape = 8,
stroke = 0.2) +
geom_errorbar(data = min_rmsd_summary,
aes(x = GroupSize,
ymin = MeanMinRMSD - MeanMinRMSDSE,
ymax = MeanMinRMSD + MeanMinRMSDSE),
colour = "black",
size = 0.3,
width = 0) +
geom_point(data = min_rmsd_summary,
aes(x = GroupSize, y = MeanMinRMSD),
size = 0.7) +
theme_classic() +
xlab("Group Size") +
ylab("Min. RMSD (mm)") +
scale_y_continuous(breaks = seq(9, 19, 1),
expand = c(0, 0.05),
labels = c('', '10', '', '12', '', '14', '', '16', '', '18', '')) +
scale_x_continuous(breaks = c(0, 2, 4, 6, 8, 12, 16),
expand = c(0, 0.0),
labels = c('', '2', '', '6', '', '12', '16')) +
scale_color_manual(values = palette) +
theme(axis.text.y = element_text(size = 6, margin = margin(0, 5, 0, -4), color = "black"),
axis.text.x = element_text(size = 6, margin = margin(5, 0, -4, 0), color = "black"),
axis.title = element_text(size = 7, margin = margin(0, 0, 0, 0)),
axis.ticks.length = unit(-0.06, "cm"),
axis.ticks = element_line(colour = "black", size = 0.3),
axis.line = element_line(size = 0.3),
plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "mm"))
gg_RMSD
ggsave("output/MSFigures/MinRMSDFigure.svg",  width = 23.5, height = 29.5, units = "mm")
ggsave("output/MSFigures/MinRMSDFigure_threeperrow.svg", width = 45, height = 35, units = "mm")
=======
tally <- transform(tally, Inactive = n - sum(X_g), n = n, replicate = sim)
taskTally[[t]] <- tally
# Update total task performance profile
X_tot <- X_tot + X_g
# Create time step for correlation
if (t %% corrStep == 0) {
# Get tasks performance in correlation step
X_step <- X_tot - X_prevTot
# Add to ensemble list of task steps
taskStep[[t / corrStep]] <- X_step
# Calculate rank correlation if it is not the first step
if(sum(X_prev) != 0) {
# Normalize
# stepNorm <- X_step / rowSums(X_step)
# prevNorm <- X_prev / rowSums(X_prev)
stepNorm <- X_step / corrStep
prevNorm <- X_prev / corrStep
# Calculate ranks
step_ranks <- calculateTaskRank(TaskStepMat = X_step)
prev_ranks <- calculateTaskRank(TaskStepMat = X_prev)
# Calculate Correlation
rankCorr <- cor(prev_ranks, step_ranks, method = "spearman")
# Put in list
taskCorr[[(t / corrStep) - 1]] <- diag(rankCorr)
names(taskCorr)[(t / corrStep) - 1] <- paste0("Gen", t)
}
# Update previous step total matrix
X_prevTot <- X_tot
# Update previous step total matrix
X_prev <- X_step
}
}
# Calculate Entropy
entropy <- mutualEntropy(TotalStateMat = X_tot)
entropy <- transform(entropy, n = n, replicate = sim)
# Calculate total task distribution
# totalTaskDist <- X_tot / rowSums(X_tot)
totalTaskDist <- X_tot / gens
totalTaskDist <- transform(totalTaskDist, Inactive = gens - rowSums(X_tot), n = n, replicate = sim)
# Create tasktally table
taskTally <- do.call("rbind", taskTally)
# Create tasktally table
stimMat <- transform(stimMat, n = n, replicate = sim)
# Add total task distributions, entropy values, and graphs to lists
ens_taskDist[[sim]]  <- totalTaskDist
ens_entropy[[sim]]   <- entropy
ens_taskCorr[[sim]]  <- taskCorr
ens_taskTally[[sim]] <- taskTally
ens_taskStep[[sim]]  <- taskStep
ens_stim[[sim]]      <- stimMat
# Print simulation completed
print(paste0("DONE: N = ", n, ", Simulation ", sim))
}
# Calculate mean correlation for each n
runCorrs <- lapply(ens_taskCorr, function(x) {
# Unlist
runs <- do.call("rbind", x)
# Calculate mean
runMean <- matrix(data = rep(NA, m), ncol =  m)
for (column in 1:m) {
runMean[ , column] <- mean(runs[ , column], na.rm = TRUE)
}
colnames(runMean) <- colnames(runs)
return(runMean)
})
runCorrs <- do.call("rbind", runCorrs)
runCorrs <- transform(runCorrs, n = n)
# Add to list of lists
groups_taskDist[[i]]  <- ens_taskDist
groups_taskCorr[[i]]  <- runCorrs
groups_taskStep[[i]]  <- ens_taskStep
groups_taskTally[[i]] <- ens_taskTally
groups_stim[[i]]      <- ens_stim
groups_entropy[[i]]   <- ens_entropy
}
# trim out correlations for group size 1
if(1 %in% Ns) {
groups_taskCorr <- groups_taskCorr[-1]
}
X_step <- X_tot - X_prevTot
# Add to ensemble list of task steps
taskStep[[t / corrStep]] <- X_step
stepNorm <- X_step / corrStep
prevNorm <- X_prev / corrStep
# Calculate ranks
step_ranks <- calculateTaskRank(TaskStepMat = X_step)
prev_ranks <- calculateTaskRank(TaskStepMat = X_prev)
# Calculate Correlation
rankCorr <- cor(prev_ranks, step_ranks, method = "spearman")
# Put in list
taskCorr[[(t / corrStep) - 1]] <- diag(rankCorr)
names(taskCorr)[(t / corrStep) - 1] <- paste0("Gen", t)
rankCorr
prev_ranks
plot(prev_ranks[,2], step_ranks[,2])
plot(prev_ranks[,``], step_ranks[,``])
plot(prev_ranks[,1], step_ranks[,1])
plot(prev_ranks[,1], step_ranks[,2])
plot(prev_ranks[,2], step_ranks[,1])
taskCorr[[(t / corrStep) - 1]] <-
diag(rankCorr)
taskCorr
ens_taskCorr
rm(list = ls())
source("scripts/__Util__MASTER.R")
source("scripts/3_PrepPlotExperimentData.R")
load("/Users/ChrisTokita/Documents/Research/Tarnita Lab/Incipient Groups DOL/Fixed_Delta06Sigma01Eta7LargerGroups100reps.Rdata")
# Set variable
filename <- "Fixed_Delta06Sigma01Eta7LargerGroups"
# Palette without single individuals
#palette <- c("#F00924", "#F7A329", "#FDD545", "#027C2C", "#1D10F9", "#4C0E78", "#bdbdbd", "#525252")
# Palette without single individuals
palette <- c("#83343E", "#F00924", "#F7A329", "#FDD545", "#027C2C", "#1D10F9", "#4C0E78", "#bdbdbd", "#525252")
# Model vs Data Palette
compPalette <- c("indianred2", "black")
####################
# Task variance by group size
####################
# Prep
taskVarMean <- taskDistTot %>%
mutate(n = as.character(n)) %>%
mutate(n = as.numeric(n)) %>%
group_by(n, replicate) %>%
summarise(SD1 = sd(Task1),
SD2 = sd(Task2),
Mean1 = mean(Task1),
Mean2 = mean(Task2)) %>%
mutate(Source = "Model",
SD = (SD1 + SD2) / 2,
Mean = (Mean1 + Mean2) / 2)
taskVarMean$SD[is.na(taskVarMean$SD)] <- 0 #fix for single individuals
taskVarMean <- rbind(taskVarMean, yukoDataSummary)
# Calculate means and SE
taskVarMeans <- taskVarMean %>%
group_by(n, Source) %>%
summarise(MeanMean = mean(Mean),
MeanSE = sd(Mean) / sqrt(length(Mean)),
SDMean = mean(SD),
SDSE = sd(SD) / sqrt(length(SD)))
####################
# Final task distributions
####################
# Bind together
taskDist <- unlist(groups_taskDist, recursive = FALSE)
taskDistTot <- do.call("rbind", taskDist)
####################
# Task variance by group size
####################
# Prep
taskVarMean <- taskDistTot %>%
mutate(n = as.character(n)) %>%
mutate(n = as.numeric(n)) %>%
group_by(n, replicate) %>%
summarise(SD1 = sd(Task1),
SD2 = sd(Task2),
Mean1 = mean(Task1),
Mean2 = mean(Task2)) %>%
mutate(Source = "Model",
SD = (SD1 + SD2) / 2,
Mean = (Mean1 + Mean2) / 2)
taskVarMean$SD[is.na(taskVarMean$SD)] <- 0 #fix for single individuals
taskVarMean <- rbind(taskVarMean, yukoDataSummary)
# Calculate means and SE
taskVarMeans <- taskVarMean %>%
group_by(n, Source) %>%
summarise(MeanMean = mean(Mean),
MeanSE = sd(Mean) / sqrt(length(Mean)),
SDMean = mean(SD),
SDSE = sd(SD) / sqrt(length(SD)))
View(taskVarMeans)
taskVarMeans <- taskVarMeans %>% filter(n < 30)
# Get mean at group size one and normalize
expSizeOne <- taskVarMeans$MeanMean[taskVarMeans$n == 1 & taskVarMeans$Source == "Experiment"]
modSizeOne <- taskVarMeans$MeanMean[taskVarMeans$n == 1 & taskVarMeans$Source == "Model"]
expSizeSixteen <- taskVarMeans$SDMean[taskVarMeans$n == 16 & taskVarMeans$Source == "Experiment"]
modSizeSixteen <- taskVarMeans$SDMean[taskVarMeans$n == 16 & taskVarMeans$Source == "Model"]
# Normalize Mean Values
taskVarMeans$NormMean <- NA
taskVarMeans$NormMeanSE <- NA
taskVarMeans$NormMean[taskVarMeans$Source == "Experiment"] <- taskVarMeans$MeanMean[taskVarMeans$Source == "Experiment"] / expSizeOne
taskVarMeans$NormMean[taskVarMeans$Source == "Model"] <- taskVarMeans$MeanMean[taskVarMeans$Source == "Model"] / modSizeOne
taskVarMeans$NormMeanSE[taskVarMeans$Source == "Experiment"] <- taskVarMeans$MeanSE[taskVarMeans$Source == "Experiment"] / expSizeOne
taskVarMeans$NormMeanSE[taskVarMeans$Source == "Model"] <- taskVarMeans$MeanSE[taskVarMeans$Source == "Model"] / modSizeOne
taskVarMean$NormMean <- NA
taskVarMean$NormMean[taskVarMean$Source == "Experiment"] <- taskVarMean$Mean[taskVarMean$Source == "Experiment"] / expSizeOne
taskVarMean$NormMean[taskVarMean$Source == "Model"] <- taskVarMean$Mean[taskVarMean$Source == "Model"] / modSizeOne
# Normalize behavioral variation values
taskVarMeans$NormVarMean <- NA
taskVarMeans$NormVarMeanSE <- NA
taskVarMeans$NormVarMean[taskVarMeans$Source == "Experiment"] <- taskVarMeans$SDMean[taskVarMeans$Source == "Experiment"] / expSizeSixteen
taskVarMeans$NormVarMean[taskVarMeans$Source == "Model"] <- taskVarMeans$SDMean[taskVarMeans$Source == "Model"] / modSizeSixteen
taskVarMeans$NormVarMeanSE[taskVarMeans$Source == "Experiment"] <- taskVarMeans$SDSE[taskVarMeans$Source == "Experiment"] / expSizeSixteen
taskVarMeans$NormVarMeanSE[taskVarMeans$Source == "Model"] <- taskVarMeans$SDSE[taskVarMeans$Source == "Model"] / modSizeSixteen
taskVarMean$NormVarMean <- NA
taskVarMean$NormVarMean[taskVarMean$Source == "Experiment"] <- taskVarMean$SD[taskVarMean$Source == "Experiment"] / expSizeSixteen
taskVarMean$NormVarMean[taskVarMean$Source == "Model"] <- taskVarMean$SD[taskVarMean$Source == "Model"] / modSizeSixteen
# Prep for broken axis plot
taskVarMean <- as.data.frame(taskVarMean)
taskVarMeans <- as.data.frame(taskVarMeans)
View(taskVarMeans)
taskVarMeans
View(taskVarMean)
####################
# Parameter Space Exploration
####################
rm(list = ls())
source("scripts/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
##### Delta 06 #####
# load
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExplorationEXTRA.Rdata")
improve1 <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExplorationEXTRA2.Rdata")
improve2 <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExploration.Rdata")
improve <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
improve06 <- rbind(improve, improve1, improve2)
rm(improve, improve1, improve2)
# Filter to size
improve06 <- improve06 %>%
filter(!sigma %in% c(0.075, 0.125, 0.175, 0.225, 0.275, 0.325))
##### Absolute Slope #####
# Colors
myPalette <- colorRampPalette(brewer.pal(6, "YlOrRd"))
colPal <- c(myPalette(6), "#800026")
spec.loess <- loess(Increase ~ sigma * threshSlope, data = improve06, degree = 2, span = 0.1)
spec.fit <- expand.grid(list(sigma = seq(0, max(improve06$sigma), (max(improve06$sigma) - min(improve06$sigma)) / 1000),
threshSlope = seq(1, max(improve06$threshSlope), (max(improve06$threshSlope) - min(improve06$threshSlope)) / 1000)))
z <- predict(spec.loess, newdata = spec.fit)
spec.fit$spec <- as.numeric(z)
spec.fit$CloseIncrease <- ifelse(spec.fit$spec >= 0.2926124 & spec.fit$spec <= 0.3576374, 0.5, 0)
View(spec.fit)
source("scripts/3_PrepPlotExperimentData.R")
taskCorrTot <- do.call("rbind", groups_taskCorr)
taskCorrTot <- taskCorrTot %>%
mutate(TaskMean = (Task1 + Task2) / 2)
# Manipulate and bind with Yuko data
taskCorrTot <- taskCorrTot %>%
mutate(Source = "Model") %>%
select(n, TaskMean, Source) %>%
rbind(yukoCorr) %>%
mutate(Source = as.factor(Source))
taskCorrTot <- as.data.frame(taskCorrTot)
# Calculate means and SE
taskCorrMeans <- taskCorrTot %>%
group_by(Source, n) %>%
summarise(SpecMean = mean(TaskMean),
SpecSE = sd(TaskMean) / sqrt(length(TaskMean)),
SpecCI = 1.96 * SpecSE)
taskDist <- unlist(groups_taskDist, recursive = FALSE)
taskDistTot <- do.call("rbind", taskDist)
View(yukoCorr)
rm(list = ls())
source("scripts/__Util__MASTER.R")
source("scripts/3_PrepPlotExperimentData.R")
load("/Users/ChrisTokita/Documents/Research/Tarnita Lab/Incipient Groups DOL/Fixed_Delta06Sigma01Eta7LargerGroups100reps.Rdata")
# Set variable
filename <- "Fixed_Delta06Sigma01Eta7LargerGroups"
# Palette without single individuals
#palette <- c("#F00924", "#F7A329", "#FDD545", "#027C2C", "#1D10F9", "#4C0E78", "#bdbdbd", "#525252")
# Palette without single individuals
palette <- c("#83343E", "#F00924", "#F7A329", "#FDD545", "#027C2C", "#1D10F9", "#4C0E78", "#bdbdbd", "#525252")
# Model vs Data Palette
compPalette <- c("indianred2", "black")
####################
taskCorrTot <- do.call("rbind", groups_taskCorr)
taskCorrTot <- taskCorrTot %>%
mutate(TaskMean = (Task1 + Task2) / 2)
# Manipulate and bind with Yuko data
taskCorrTot <- taskCorrTot %>%
mutate(Source = "Model") %>%
select(n, TaskMean, Source) %>%
rbind(yukoCorr) %>%
mutate(Source = as.factor(Source))
taskCorrTot <- as.data.frame(taskCorrTot)
# Calculate means and SE
taskCorrMeans <- taskCorrTot %>%
group_by(Source, n) %>%
summarise(SpecMean = mean(TaskMean),
SpecSE = sd(TaskMean) / sqrt(length(TaskMean)),
SpecCI = 1.96 * SpecSE)
# Set for broken axis
addrows <- data.frame(Source = rep("Model", 2),
n = c(37, 95),
SpecMean = c(0.6673539, 0.6885347),
SpecSE = c(NA, NA),
SpecCI = c(NA, NA))
taskCorrMeans <- as.data.frame(taskCorrMeans)
taskCorrMeans <- rbind(taskCorrMeans, addrows)
taskCorrMeans$mask <- 0
taskCorrMeans$mask[taskCorrMeans$n > 90] <- 1
taskCorrTot$mask <- 0
taskCorrTot$mask[taskCorrTot$n > 90] <- 1
# Plot
gg_corr <- ggplot() +
# geom_hline(data = taskCorrTot,
#            aes(yintercept = 0),
#            colour = "grey30") +
geom_point(data = taskCorrTot,
aes(x = n, y = TaskMean, fill = Source, colour = Source),
size = 1,
stroke = 0,
position = position_dodge(width = 2),
alpha = 0.4) +
theme_classic() +
labs(x = "Group size",
y = "Specialization") +
scale_x_continuous(breaks = unique(taskCorrTot$n)) +
scale_y_continuous(breaks = seq(-1, 1, 0.2)) +
scale_size_manual(values = c(2, 2, 2, 2, 2, 2, 2, -1, -1, 2)) +
scale_fill_manual(values = compPalette) +
scale_colour_manual(values = compPalette) +
theme(legend.position = "none",
axis.text = element_text(size = 8, colour = "black"),
axis.title = element_text(size = 10),
strip.text = element_blank(),
strip.background = element_blank(),
panel.spacing = unit(0.25, "cm")) +
# Mean and SE portion of plot
geom_errorbar(data = taskCorrMeans,
aes(x = n, ymin = SpecMean - SpecSE, ymax = SpecMean + SpecSE, colour = Source),
width = 5,
position = position_dodge(width = 1)) +
geom_point(data = taskCorrMeans,
aes(x = n, y = SpecMean, colour = Source, fill = Source, size = as.factor(n)),
position = position_dodge(width = 1)) +
geom_line(data = taskCorrMeans,
aes(x = n, y = SpecMean,  colour = Source),
position = position_dodge(width = 1)) +
facet_grid(. ~ mask, scales = "free", space = "free")
View(taskCorrMeans)
0.5915000 - 0.2663750
0.325125 *0.9
0.325125 *1.1
taskCorrMeans$SpecMean[taskCorrMeans$n == 16 & taskCorrMeans$Source == "Experiment"]
taskCorrMeans$SpecMean[taskCorrMeans$n == 16 & taskCorrMeans$Source == "Experiment"] - taskCorrMeans$SpecMean[taskCorrMeans$n == 2 & taskCorrMeans$Source == "Experiment"]
0.325125 * 0.9
rm(list = ls())
source("scripts/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
##### Delta 06 #####
# load
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExplorationEXTRA.Rdata")
improve1 <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExplorationEXTRA2.Rdata")
improve2 <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExploration.Rdata")
improve <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
improve06 <- rbind(improve, improve1, improve2)
rm(improve, improve1, improve2)
# Filter to size
improve06 <- improve06 %>%
filter(!sigma %in% c(0.075, 0.125, 0.175, 0.225, 0.275, 0.325))
##### Absolute Slope #####
# Colors
myPalette <- colorRampPalette(brewer.pal(6, "YlOrRd"))
colPal <- c(myPalette(6), "#800026")
# Fit surface
spec.loess <- loess(Increase ~ sigma * threshSlope, data = improve06, degree = 2, span = 0.1)
spec.fit <- expand.grid(list(sigma = seq(0, max(improve06$sigma), (max(improve06$sigma) - min(improve06$sigma)) / 1000),
threshSlope = seq(1, max(improve06$threshSlope), (max(improve06$threshSlope) - min(improve06$threshSlope)) / 1000)))
z <- predict(spec.loess, newdata = spec.fit)
spec.fit$spec <- as.numeric(z)
# Approximated +/- 10% of experimental data
# Experimental slope: 0.5915000 - 0.2663750 = 0.325125
spec.fit$CloseIncrease <- ifelse(spec.fit$spec >= 0.2926124 & spec.fit$spec <= 0.3576374, 0.5, 0)
View(spec.fit)
# Graph
gg_abslope <- ggplot() +
geom_raster(data = improve06,
aes(x = sigma,
y = threshSlope,
fill = Increase)) +
stat_contour(data = spec.fit,
aes(x = sigma,
y = threshSlope,
z = spec),
size = 0.35,
colour = "white",
breaks = c(0.2926124)) +
stat_contour(data = spec.fit,
aes(x = sigma,
y = threshSlope,
z = spec),
size = 0.35,
colour = "white",
linetype = "dashed",
breaks = c(0.3576374)) +
theme_bw() +
scale_x_continuous(expand = c(0, -0.002)) +
scale_y_continuous(expand = c(0, -0.2), breaks = c(1, seq(10, 30, 10))) +
scale_fill_gradientn(name = "Specialization\nIncrease",
colors = colPal,
breaks = seq(0, 0.5, 0.1),
colours = colPal,
limits = c(0, 0.5),
oob = squish) +
scale_colour_gradientn(name = "Specialization\nIncrease",
colors = colPal,
breaks = seq(0, 0.5, 0.1),
colours = colPal,
limits = c(0, 0.5),
oob = squish) +
xlab(expression(sigma)) +
ylab(expression(eta)) +
theme(legend.position = "none",
# legend.key.height = unit(0.84, "cm"),
legend.key.height = unit(0.17, "npc"),
legend.key.width= unit(0.2, "cm"),
legend.key = element_rect(colour = "black", size = 0.5),
legend.margin =  margin(t = 0, r = 0, b = 0, l = -0.2, "cm"),
legend.text = element_text(size = 6),
legend.title = element_blank(),
axis.text.y = element_text(size = 8, margin = margin(5, 2, 5, -2), color = "black"),
axis.text.x = element_text(size = 8, margin = margin(2, 5, -2, 5), color = "black"),
axis.title = element_text(size = 11, margin = margin(0, 0, 0, 0)),
axis.ticks.length = unit(0, "cm"),
panel.border = element_rect(fill = "NA", size = 1))
gg_abslope
0.325125 * 1.1
# Graph
gg_abslope <- ggplot() +
geom_raster(data = improve06,
aes(x = sigma,
y = threshSlope,
fill = Increase)) +
stat_contour(data = spec.fit,
aes(x = sigma,
y = threshSlope,
z = spec),
size = 0.35,
colour = "white",
breaks = c(0.2926125)) +
stat_contour(data = spec.fit,
aes(x = sigma,
y = threshSlope,
z = spec),
size = 0.35,
colour = "white",
linetype = "dashed",
breaks = c(0.3576375)) +
theme_bw() +
scale_x_continuous(expand = c(0, -0.002)) +
scale_y_continuous(expand = c(0, -0.2), breaks = c(1, seq(10, 30, 10))) +
scale_fill_gradientn(name = "Specialization\nIncrease",
colors = colPal,
breaks = seq(0, 0.5, 0.1),
colours = colPal,
limits = c(0, 0.5),
oob = squish) +
scale_colour_gradientn(name = "Specialization\nIncrease",
colors = colPal,
breaks = seq(0, 0.5, 0.1),
colours = colPal,
limits = c(0, 0.5),
oob = squish) +
xlab(expression(sigma)) +
ylab(expression(eta)) +
theme(legend.position = "none",
# legend.key.height = unit(0.84, "cm"),
legend.key.height = unit(0.17, "npc"),
legend.key.width= unit(0.2, "cm"),
legend.key = element_rect(colour = "black", size = 0.5),
legend.margin =  margin(t = 0, r = 0, b = 0, l = -0.2, "cm"),
legend.text = element_text(size = 6),
legend.title = element_blank(),
=======
tally <- transform(tally, Inactive = n - sum(X_g), n = n, replicate = sim)
taskTally[[t]] <- tally
# Update total task performance profile
X_tot <- X_tot + X_g
# Create time step for correlation
if (t %% corrStep == 0) {
# Get tasks performance in correlation step
X_step <- X_tot - X_prevTot
# Add to ensemble list of task steps
taskStep[[t / corrStep]] <- X_step
# Calculate rank correlation if it is not the first step
if(sum(X_prev) != 0) {
# Normalize
# stepNorm <- X_step / rowSums(X_step)
# prevNorm <- X_prev / rowSums(X_prev)
stepNorm <- X_step / corrStep
prevNorm <- X_prev / corrStep
# Calculate ranks
step_ranks <- calculateTaskRank(TaskStepMat = X_step)
prev_ranks <- calculateTaskRank(TaskStepMat = X_prev)
# Calculate Correlation
rankCorr <- cor(prev_ranks, step_ranks, method = "spearman")
# Put in list
taskCorr[[(t / corrStep) - 1]] <- diag(rankCorr)
names(taskCorr)[(t / corrStep) - 1] <- paste0("Gen", t)
}
# Update previous step total matrix
X_prevTot <- X_tot
# Update previous step total matrix
X_prev <- X_step
}
}
# Calculate Entropy
entropy <- mutualEntropy(TotalStateMat = X_tot)
entropy <- transform(entropy, n = n, replicate = sim)
# Calculate total task distribution
# totalTaskDist <- X_tot / rowSums(X_tot)
totalTaskDist <- X_tot / gens
totalTaskDist <- transform(totalTaskDist, Inactive = gens - rowSums(X_tot), n = n, replicate = sim)
# Create tasktally table
taskTally <- do.call("rbind", taskTally)
# Create tasktally table
stimMat <- transform(stimMat, n = n, replicate = sim)
# Add total task distributions, entropy values, and graphs to lists
ens_taskDist[[sim]]  <- totalTaskDist
ens_entropy[[sim]]   <- entropy
ens_taskCorr[[sim]]  <- taskCorr
ens_taskTally[[sim]] <- taskTally
ens_taskStep[[sim]]  <- taskStep
ens_stim[[sim]]      <- stimMat
# Print simulation completed
print(paste0("DONE: N = ", n, ", Simulation ", sim))
}
# Calculate mean correlation for each n
runCorrs <- lapply(ens_taskCorr, function(x) {
# Unlist
runs <- do.call("rbind", x)
# Calculate mean
runMean <- matrix(data = rep(NA, m), ncol =  m)
for (column in 1:m) {
runMean[ , column] <- mean(runs[ , column], na.rm = TRUE)
}
colnames(runMean) <- colnames(runs)
return(runMean)
})
runCorrs <- do.call("rbind", runCorrs)
runCorrs <- transform(runCorrs, n = n)
# Add to list of lists
groups_taskDist[[i]]  <- ens_taskDist
groups_taskCorr[[i]]  <- runCorrs
groups_taskStep[[i]]  <- ens_taskStep
groups_taskTally[[i]] <- ens_taskTally
groups_stim[[i]]      <- ens_stim
groups_entropy[[i]]   <- ens_entropy
}
# trim out correlations for group size 1
if(1 %in% Ns) {
groups_taskCorr <- groups_taskCorr[-1]
}
X_step <- X_tot - X_prevTot
# Add to ensemble list of task steps
taskStep[[t / corrStep]] <- X_step
stepNorm <- X_step / corrStep
prevNorm <- X_prev / corrStep
# Calculate ranks
step_ranks <- calculateTaskRank(TaskStepMat = X_step)
prev_ranks <- calculateTaskRank(TaskStepMat = X_prev)
# Calculate Correlation
rankCorr <- cor(prev_ranks, step_ranks, method = "spearman")
# Put in list
taskCorr[[(t / corrStep) - 1]] <- diag(rankCorr)
names(taskCorr)[(t / corrStep) - 1] <- paste0("Gen", t)
rankCorr
prev_ranks
plot(prev_ranks[,2], step_ranks[,2])
plot(prev_ranks[,``], step_ranks[,``])
plot(prev_ranks[,1], step_ranks[,1])
plot(prev_ranks[,1], step_ranks[,2])
plot(prev_ranks[,2], step_ranks[,1])
taskCorr[[(t / corrStep) - 1]] <-
diag(rankCorr)
taskCorr
ens_taskCorr
rm(list = ls())
source("scripts/__Util__MASTER.R")
source("scripts/3_PrepPlotExperimentData.R")
load("/Users/ChrisTokita/Documents/Research/Tarnita Lab/Incipient Groups DOL/Fixed_Delta06Sigma01Eta7LargerGroups100reps.Rdata")
# Set variable
filename <- "Fixed_Delta06Sigma01Eta7LargerGroups"
# Palette without single individuals
#palette <- c("#F00924", "#F7A329", "#FDD545", "#027C2C", "#1D10F9", "#4C0E78", "#bdbdbd", "#525252")
# Palette without single individuals
palette <- c("#83343E", "#F00924", "#F7A329", "#FDD545", "#027C2C", "#1D10F9", "#4C0E78", "#bdbdbd", "#525252")
# Model vs Data Palette
compPalette <- c("indianred2", "black")
####################
# Task variance by group size
####################
# Prep
taskVarMean <- taskDistTot %>%
mutate(n = as.character(n)) %>%
mutate(n = as.numeric(n)) %>%
group_by(n, replicate) %>%
summarise(SD1 = sd(Task1),
SD2 = sd(Task2),
Mean1 = mean(Task1),
Mean2 = mean(Task2)) %>%
mutate(Source = "Model",
SD = (SD1 + SD2) / 2,
Mean = (Mean1 + Mean2) / 2)
taskVarMean$SD[is.na(taskVarMean$SD)] <- 0 #fix for single individuals
taskVarMean <- rbind(taskVarMean, yukoDataSummary)
# Calculate means and SE
taskVarMeans <- taskVarMean %>%
group_by(n, Source) %>%
summarise(MeanMean = mean(Mean),
MeanSE = sd(Mean) / sqrt(length(Mean)),
SDMean = mean(SD),
SDSE = sd(SD) / sqrt(length(SD)))
####################
# Final task distributions
####################
# Bind together
taskDist <- unlist(groups_taskDist, recursive = FALSE)
taskDistTot <- do.call("rbind", taskDist)
####################
# Task variance by group size
####################
# Prep
taskVarMean <- taskDistTot %>%
mutate(n = as.character(n)) %>%
mutate(n = as.numeric(n)) %>%
group_by(n, replicate) %>%
summarise(SD1 = sd(Task1),
SD2 = sd(Task2),
Mean1 = mean(Task1),
Mean2 = mean(Task2)) %>%
mutate(Source = "Model",
SD = (SD1 + SD2) / 2,
Mean = (Mean1 + Mean2) / 2)
taskVarMean$SD[is.na(taskVarMean$SD)] <- 0 #fix for single individuals
taskVarMean <- rbind(taskVarMean, yukoDataSummary)
# Calculate means and SE
taskVarMeans <- taskVarMean %>%
group_by(n, Source) %>%
summarise(MeanMean = mean(Mean),
MeanSE = sd(Mean) / sqrt(length(Mean)),
SDMean = mean(SD),
SDSE = sd(SD) / sqrt(length(SD)))
View(taskVarMeans)
taskVarMeans <- taskVarMeans %>% filter(n < 30)
# Get mean at group size one and normalize
expSizeOne <- taskVarMeans$MeanMean[taskVarMeans$n == 1 & taskVarMeans$Source == "Experiment"]
modSizeOne <- taskVarMeans$MeanMean[taskVarMeans$n == 1 & taskVarMeans$Source == "Model"]
expSizeSixteen <- taskVarMeans$SDMean[taskVarMeans$n == 16 & taskVarMeans$Source == "Experiment"]
modSizeSixteen <- taskVarMeans$SDMean[taskVarMeans$n == 16 & taskVarMeans$Source == "Model"]
# Normalize Mean Values
taskVarMeans$NormMean <- NA
taskVarMeans$NormMeanSE <- NA
taskVarMeans$NormMean[taskVarMeans$Source == "Experiment"] <- taskVarMeans$MeanMean[taskVarMeans$Source == "Experiment"] / expSizeOne
taskVarMeans$NormMean[taskVarMeans$Source == "Model"] <- taskVarMeans$MeanMean[taskVarMeans$Source == "Model"] / modSizeOne
taskVarMeans$NormMeanSE[taskVarMeans$Source == "Experiment"] <- taskVarMeans$MeanSE[taskVarMeans$Source == "Experiment"] / expSizeOne
taskVarMeans$NormMeanSE[taskVarMeans$Source == "Model"] <- taskVarMeans$MeanSE[taskVarMeans$Source == "Model"] / modSizeOne
taskVarMean$NormMean <- NA
taskVarMean$NormMean[taskVarMean$Source == "Experiment"] <- taskVarMean$Mean[taskVarMean$Source == "Experiment"] / expSizeOne
taskVarMean$NormMean[taskVarMean$Source == "Model"] <- taskVarMean$Mean[taskVarMean$Source == "Model"] / modSizeOne
# Normalize behavioral variation values
taskVarMeans$NormVarMean <- NA
taskVarMeans$NormVarMeanSE <- NA
taskVarMeans$NormVarMean[taskVarMeans$Source == "Experiment"] <- taskVarMeans$SDMean[taskVarMeans$Source == "Experiment"] / expSizeSixteen
taskVarMeans$NormVarMean[taskVarMeans$Source == "Model"] <- taskVarMeans$SDMean[taskVarMeans$Source == "Model"] / modSizeSixteen
taskVarMeans$NormVarMeanSE[taskVarMeans$Source == "Experiment"] <- taskVarMeans$SDSE[taskVarMeans$Source == "Experiment"] / expSizeSixteen
taskVarMeans$NormVarMeanSE[taskVarMeans$Source == "Model"] <- taskVarMeans$SDSE[taskVarMeans$Source == "Model"] / modSizeSixteen
taskVarMean$NormVarMean <- NA
taskVarMean$NormVarMean[taskVarMean$Source == "Experiment"] <- taskVarMean$SD[taskVarMean$Source == "Experiment"] / expSizeSixteen
taskVarMean$NormVarMean[taskVarMean$Source == "Model"] <- taskVarMean$SD[taskVarMean$Source == "Model"] / modSizeSixteen
# Prep for broken axis plot
taskVarMean <- as.data.frame(taskVarMean)
taskVarMeans <- as.data.frame(taskVarMeans)
View(taskVarMeans)
taskVarMeans
View(taskVarMean)
####################
# Parameter Space Exploration
####################
rm(list = ls())
source("scripts/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
##### Delta 06 #####
# load
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExplorationEXTRA.Rdata")
improve1 <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExplorationEXTRA2.Rdata")
improve2 <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExploration.Rdata")
improve <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
improve06 <- rbind(improve, improve1, improve2)
rm(improve, improve1, improve2)
# Filter to size
improve06 <- improve06 %>%
filter(!sigma %in% c(0.075, 0.125, 0.175, 0.225, 0.275, 0.325))
##### Absolute Slope #####
# Colors
myPalette <- colorRampPalette(brewer.pal(6, "YlOrRd"))
colPal <- c(myPalette(6), "#800026")
spec.loess <- loess(Increase ~ sigma * threshSlope, data = improve06, degree = 2, span = 0.1)
spec.fit <- expand.grid(list(sigma = seq(0, max(improve06$sigma), (max(improve06$sigma) - min(improve06$sigma)) / 1000),
threshSlope = seq(1, max(improve06$threshSlope), (max(improve06$threshSlope) - min(improve06$threshSlope)) / 1000)))
z <- predict(spec.loess, newdata = spec.fit)
spec.fit$spec <- as.numeric(z)
spec.fit$CloseIncrease <- ifelse(spec.fit$spec >= 0.2926124 & spec.fit$spec <= 0.3576374, 0.5, 0)
View(spec.fit)
source("scripts/3_PrepPlotExperimentData.R")
taskCorrTot <- do.call("rbind", groups_taskCorr)
taskCorrTot <- taskCorrTot %>%
mutate(TaskMean = (Task1 + Task2) / 2)
# Manipulate and bind with Yuko data
taskCorrTot <- taskCorrTot %>%
mutate(Source = "Model") %>%
select(n, TaskMean, Source) %>%
rbind(yukoCorr) %>%
mutate(Source = as.factor(Source))
taskCorrTot <- as.data.frame(taskCorrTot)
# Calculate means and SE
taskCorrMeans <- taskCorrTot %>%
group_by(Source, n) %>%
summarise(SpecMean = mean(TaskMean),
SpecSE = sd(TaskMean) / sqrt(length(TaskMean)),
SpecCI = 1.96 * SpecSE)
taskDist <- unlist(groups_taskDist, recursive = FALSE)
taskDistTot <- do.call("rbind", taskDist)
View(yukoCorr)
rm(list = ls())
source("scripts/__Util__MASTER.R")
source("scripts/3_PrepPlotExperimentData.R")
load("/Users/ChrisTokita/Documents/Research/Tarnita Lab/Incipient Groups DOL/Fixed_Delta06Sigma01Eta7LargerGroups100reps.Rdata")
# Set variable
filename <- "Fixed_Delta06Sigma01Eta7LargerGroups"
# Palette without single individuals
#palette <- c("#F00924", "#F7A329", "#FDD545", "#027C2C", "#1D10F9", "#4C0E78", "#bdbdbd", "#525252")
# Palette without single individuals
palette <- c("#83343E", "#F00924", "#F7A329", "#FDD545", "#027C2C", "#1D10F9", "#4C0E78", "#bdbdbd", "#525252")
# Model vs Data Palette
compPalette <- c("indianred2", "black")
####################
taskCorrTot <- do.call("rbind", groups_taskCorr)
taskCorrTot <- taskCorrTot %>%
mutate(TaskMean = (Task1 + Task2) / 2)
# Manipulate and bind with Yuko data
taskCorrTot <- taskCorrTot %>%
mutate(Source = "Model") %>%
select(n, TaskMean, Source) %>%
rbind(yukoCorr) %>%
mutate(Source = as.factor(Source))
taskCorrTot <- as.data.frame(taskCorrTot)
# Calculate means and SE
taskCorrMeans <- taskCorrTot %>%
group_by(Source, n) %>%
summarise(SpecMean = mean(TaskMean),
SpecSE = sd(TaskMean) / sqrt(length(TaskMean)),
SpecCI = 1.96 * SpecSE)
# Set for broken axis
addrows <- data.frame(Source = rep("Model", 2),
n = c(37, 95),
SpecMean = c(0.6673539, 0.6885347),
SpecSE = c(NA, NA),
SpecCI = c(NA, NA))
taskCorrMeans <- as.data.frame(taskCorrMeans)
taskCorrMeans <- rbind(taskCorrMeans, addrows)
taskCorrMeans$mask <- 0
taskCorrMeans$mask[taskCorrMeans$n > 90] <- 1
taskCorrTot$mask <- 0
taskCorrTot$mask[taskCorrTot$n > 90] <- 1
# Plot
gg_corr <- ggplot() +
# geom_hline(data = taskCorrTot,
#            aes(yintercept = 0),
#            colour = "grey30") +
geom_point(data = taskCorrTot,
aes(x = n, y = TaskMean, fill = Source, colour = Source),
size = 1,
stroke = 0,
position = position_dodge(width = 2),
alpha = 0.4) +
theme_classic() +
labs(x = "Group size",
y = "Specialization") +
scale_x_continuous(breaks = unique(taskCorrTot$n)) +
scale_y_continuous(breaks = seq(-1, 1, 0.2)) +
scale_size_manual(values = c(2, 2, 2, 2, 2, 2, 2, -1, -1, 2)) +
scale_fill_manual(values = compPalette) +
scale_colour_manual(values = compPalette) +
theme(legend.position = "none",
axis.text = element_text(size = 8, colour = "black"),
axis.title = element_text(size = 10),
strip.text = element_blank(),
strip.background = element_blank(),
panel.spacing = unit(0.25, "cm")) +
# Mean and SE portion of plot
geom_errorbar(data = taskCorrMeans,
aes(x = n, ymin = SpecMean - SpecSE, ymax = SpecMean + SpecSE, colour = Source),
width = 5,
position = position_dodge(width = 1)) +
geom_point(data = taskCorrMeans,
aes(x = n, y = SpecMean, colour = Source, fill = Source, size = as.factor(n)),
position = position_dodge(width = 1)) +
geom_line(data = taskCorrMeans,
aes(x = n, y = SpecMean,  colour = Source),
position = position_dodge(width = 1)) +
facet_grid(. ~ mask, scales = "free", space = "free")
View(taskCorrMeans)
0.5915000 - 0.2663750
0.325125 *0.9
0.325125 *1.1
taskCorrMeans$SpecMean[taskCorrMeans$n == 16 & taskCorrMeans$Source == "Experiment"]
taskCorrMeans$SpecMean[taskCorrMeans$n == 16 & taskCorrMeans$Source == "Experiment"] - taskCorrMeans$SpecMean[taskCorrMeans$n == 2 & taskCorrMeans$Source == "Experiment"]
0.325125 * 0.9
rm(list = ls())
source("scripts/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
##### Delta 06 #####
# load
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExplorationEXTRA.Rdata")
improve1 <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExplorationEXTRA2.Rdata")
improve2 <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
load("output/ParameterExploration/Rdata/FixedDelta06_SigmaSlopeExploration.Rdata")
improve <- improve %>%
mutate(relativePercInc = (PercIncrease - 1.220554) / 1.220554,
relativeSlope   = (SlopeIncrease - 0.02322321) / 0.02322321,
relativeLarge   = (SpecLarge - 0.5915000) / 0.5915000,
relativeSmall   = (SpecSmall - 0.2663750) / 0.2663750,
Increase        = SlopeIncrease * 14) %>%
mutate(fit = (abs(relativeLarge) + abs(relativeSmall) + abs(relativeSlope)) / 3)
improve06 <- rbind(improve, improve1, improve2)
rm(improve, improve1, improve2)
# Filter to size
improve06 <- improve06 %>%
filter(!sigma %in% c(0.075, 0.125, 0.175, 0.225, 0.275, 0.325))
##### Absolute Slope #####
# Colors
myPalette <- colorRampPalette(brewer.pal(6, "YlOrRd"))
colPal <- c(myPalette(6), "#800026")
# Fit surface
spec.loess <- loess(Increase ~ sigma * threshSlope, data = improve06, degree = 2, span = 0.1)
spec.fit <- expand.grid(list(sigma = seq(0, max(improve06$sigma), (max(improve06$sigma) - min(improve06$sigma)) / 1000),
threshSlope = seq(1, max(improve06$threshSlope), (max(improve06$threshSlope) - min(improve06$threshSlope)) / 1000)))
z <- predict(spec.loess, newdata = spec.fit)
spec.fit$spec <- as.numeric(z)
# Approximated +/- 10% of experimental data
# Experimental slope: 0.5915000 - 0.2663750 = 0.325125
spec.fit$CloseIncrease <- ifelse(spec.fit$spec >= 0.2926124 & spec.fit$spec <= 0.3576374, 0.5, 0)
View(spec.fit)
# Graph
gg_abslope <- ggplot() +
geom_raster(data = improve06,
aes(x = sigma,
y = threshSlope,
fill = Increase)) +
stat_contour(data = spec.fit,
aes(x = sigma,
y = threshSlope,
z = spec),
size = 0.35,
colour = "white",
breaks = c(0.2926124)) +
stat_contour(data = spec.fit,
aes(x = sigma,
y = threshSlope,
z = spec),
size = 0.35,
colour = "white",
linetype = "dashed",
breaks = c(0.3576374)) +
theme_bw() +
scale_x_continuous(expand = c(0, -0.002)) +
scale_y_continuous(expand = c(0, -0.2), breaks = c(1, seq(10, 30, 10))) +
scale_fill_gradientn(name = "Specialization\nIncrease",
colors = colPal,
breaks = seq(0, 0.5, 0.1),
colours = colPal,
limits = c(0, 0.5),
oob = squish) +
scale_colour_gradientn(name = "Specialization\nIncrease",
colors = colPal,
breaks = seq(0, 0.5, 0.1),
colours = colPal,
limits = c(0, 0.5),
oob = squish) +
xlab(expression(sigma)) +
ylab(expression(eta)) +
theme(legend.position = "none",
# legend.key.height = unit(0.84, "cm"),
legend.key.height = unit(0.17, "npc"),
legend.key.width= unit(0.2, "cm"),
legend.key = element_rect(colour = "black", size = 0.5),
legend.margin =  margin(t = 0, r = 0, b = 0, l = -0.2, "cm"),
legend.text = element_text(size = 6),
legend.title = element_blank(),
axis.text.y = element_text(size = 8, margin = margin(5, 2, 5, -2), color = "black"),
axis.text.x = element_text(size = 8, margin = margin(2, 5, -2, 5), color = "black"),
axis.title = element_text(size = 11, margin = margin(0, 0, 0, 0)),
axis.ticks.length = unit(0, "cm"),
panel.border = element_rect(fill = "NA", size = 1))
gg_abslope
0.325125 * 1.1
# Graph
gg_abslope <- ggplot() +
geom_raster(data = improve06,
aes(x = sigma,
y = threshSlope,
fill = Increase)) +
stat_contour(data = spec.fit,
aes(x = sigma,
y = threshSlope,
z = spec),
size = 0.35,
colour = "white",
breaks = c(0.2926125)) +
stat_contour(data = spec.fit,
aes(x = sigma,
y = threshSlope,
z = spec),
size = 0.35,
colour = "white",
linetype = "dashed",
breaks = c(0.3576375)) +
theme_bw() +
scale_x_continuous(expand = c(0, -0.002)) +
scale_y_continuous(expand = c(0, -0.2), breaks = c(1, seq(10, 30, 10))) +
scale_fill_gradientn(name = "Specialization\nIncrease",
colors = colPal,
breaks = seq(0, 0.5, 0.1),
colours = colPal,
limits = c(0, 0.5),
oob = squish) +
scale_colour_gradientn(name = "Specialization\nIncrease",
colors = colPal,
breaks = seq(0, 0.5, 0.1),
colours = colPal,
limits = c(0, 0.5),
oob = squish) +
xlab(expression(sigma)) +
ylab(expression(eta)) +
theme(legend.position = "none",
# legend.key.height = unit(0.84, "cm"),
legend.key.height = unit(0.17, "npc"),
legend.key.width= unit(0.2, "cm"),
legend.key = element_rect(colour = "black", size = 0.5),
legend.margin =  margin(t = 0, r = 0, b = 0, l = -0.2, "cm"),
legend.text = element_text(size = 6),
legend.title = element_blank(),
>>>>>>> fb50a7e0ccbe47df16bd716273749bdfd7fadd3b
axis.text.y = element_text(size = 8, margin = margin(5, 2, 5, -2), color = "black"),
axis.text.x = element_text(size = 8, margin = margin(2, 5, -2, 5), color = "black"),
axis.title = element_text(size = 11, margin = margin(0, 0, 0, 0)),
axis.ticks.length = unit(0, "cm"),
panel.border = element_rect(fill = "NA", size = 1))
gg_abslope
View(spec.fit)
100000/200
<<<<<<< HEAD
>>>>>>> fb50a7e0ccbe47df16bd716273749bdfd7fadd3b
=======
>>>>>>> fb50a7e0ccbe47df16bd716273749bdfd7fadd3b
